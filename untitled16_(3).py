# -*- coding: utf-8 -*-
"""Untitled16 (3).ipynb

Automatically generated by Colaboratory.

Original file is located at
    https://colab.research.google.com/drive/1Y4Z-FvYLdTsGll27_styAW_pRMf19Im7

# New Section
"""

#LSTM
import numpy as np
import pandas as pd
from keras.models import Sequential
from keras.layers import LSTM, Dense
from sklearn.preprocessing import MinMaxScaler
from sklearn.metrics import mean_squared_error

# Load and preprocess the data
data = pd.read_csv('stock data.csv')
data = data['Close Price'].values.reshape(-1, 1)
scaler = MinMaxScaler(feature_range=(0, 1))
data = scaler.fit_transform(data)

# Split data into training and testing sets
train_size = int(len(data) * 0.8)
test_size = len(data) - train_size
train_data, test_data = data[0:train_size,:], data[train_size:len(data),:]

# Define function to create time series dataset
def create_dataset(dataset, look_back=1):
    X, Y = [], []
    for i in range(len(dataset)-look_back):
        X.append(dataset[i:(i+look_back), 0])
        Y.append(dataset[i+look_back, 0])
    return np.array(X), np.array(Y)

# Create time series dataset
look_back = 10
train_X, train_Y = create_dataset(train_data, look_back)
test_X, test_Y = create_dataset(test_data, look_back)

# Reshape input data to be [samples, time steps, features]
train_X = np.reshape(train_X, (train_X.shape[0], train_X.shape[1], 1))
test_X = np.reshape(test_X, (test_X.shape[0], test_X.shape[1], 1))

# Build LSTM model
lstm_model = Sequential()
lstm_model.add(LSTM(50, input_shape=(look_back, 1)))
lstm_model.add(Dense(1))
lstm_model.compile(loss='mean_squared_error', optimizer='adam')

# Train model
lstm_model.fit(train_X, train_Y, epochs=100, batch_size=32)

# Make predictions
train_predict = lstm_model.predict(train_X)
test_predict = lstm_model.predict(test_X)

# Invert predictions
train_predict = scaler.inverse_transform(train_predict)
train_Y = scaler.inverse_transform([train_Y])
test_predict = scaler.inverse_transform(test_predict)
test_Y = scaler.inverse_transform([test_Y])

# Calculate root mean squared error
train_score = mean_squared_error(train_Y[0], train_predict[:,0], squared=False)
print('Train Score: %.2f RMSE' % (train_score))
test_score = mean_squared_error(test_Y[0], test_predict[:,0], squared=False)
print('Test Score: %.2f RMSE' % (test_score))

train_score = mean_squared_error(train_Y[0], train_predict[:,0], squared=True)
print('Train Score: %.2f MSE' % (train_score))
test_score = mean_squared_error(test_Y[0], test_predict[:,0], squared=True)
print('Test Score: %.2f MSE' % (test_score))

import streamlit as st
import pandas as pd
import numpy as np
from sklearn.preprocessing import MinMaxScaler
from keras.models import load_model

# Load the model
model = lstm_model

# Load the scaler
scaler = MinMaxScaler(feature_range=(0,1))
scaler.fit_transform(pd.read_csv('stock data.csv')['Close Price'].values.reshape(-1,1))

# Define the Streamlit app
st.set_page_config(page_title='Stock Price Prediction App', layout='wide')
st.title('Stock Price Prediction App')
st.write('Enter the past 30 days closing prices of a stock to predict the next day closing price.')

# Define the input form
input_form = st.form(key='input_form')
input_data = input_form.text_input(label='Enter the past 30 days closing prices separated by commas')
submit_button = input_form.form_submit_button(label='Predict')

# Define the prediction function
def predict(input_data):
    # Convert the input data to a numpy array
    input_data = np.array(input_data.split(','), dtype=float)
    
    # Scale the input data
    scaled_data = scaler.transform(input_data.reshape(-1,1))
    
    # Convert the data into input sequences
    n_steps = 30
    n_features = 1
    X = np.array([scaled_data[i-n_steps:i, 0] for i in range(n_steps, len(scaled_data))])
    X = np.reshape(X, (X.shape[0], X.shape[1], n_features))
    
    # Make the prediction and inverse transform the result
    y_pred = model.predict(X)
    result = scaler.inverse_transform(y_pred)[-1][0]
    
    # Return the result as a string
    return '{:.2f}'.format(result)

# Make the prediction when the submit button is clicked
if submit_button:
    prediction = predict(input_data)
    st.write('The predicted next day closing price is:', prediction)

